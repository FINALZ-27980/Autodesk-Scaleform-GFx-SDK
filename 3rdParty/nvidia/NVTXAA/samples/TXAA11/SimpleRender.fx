
struct VS_INPUT
{
	float4 vPosition	: POSITION;
	float3 vNormal		: NORMAL;
	float2 vTexcoord	: TEXCOORD0;
};

struct VS_OUTPUT
{
	float3 vNormal		: NORMAL;
	float2 vTexcoord	: TEXCOORD0;
	float4 vPosition	: SV_POSITION;
};

struct PS_INPUT
{
	float3 vNormal		: NORMAL;
	float2 vTexcoord	: TEXCOORD0;
};

cbuffer cbConstants 
{
    matrix  World;				
    matrix  ViewProj;
};

Texture2D   DiffuseTexture;

SamplerState LinearClampSampler
{
	Filter = MIN_MAG_MIP_LINEAR;
	AddressU = Clamp;
	AddressV = Clamp;
};

SamplerState PointClampSampler
{
	Filter = MIN_MAG_MIP_POINT;
	AddressU = Clamp;
	AddressV = Clamp;
};


VS_OUTPUT VS( VS_INPUT input )
{
    VS_OUTPUT output = (VS_OUTPUT)0;
	float4 worldPos = mul(input.vPosition,World );
	output.vPosition = mul(worldPos,ViewProj );
	output.vNormal = mul(input.vNormal.xyz, (float3x3)World );
	output.vTexcoord = input.vTexcoord;
	return output;
}

float4 PS( PS_INPUT In ) : SV_TARGET
{ 
	float4 color = DiffuseTexture.Sample( LinearClampSampler, In.vTexcoord );
	float3 vDirectionalLight = normalize(float3(0, 0.1f, 0));
	float halfLambert = .5f + .5f*dot(In.vNormal, vDirectionalLight);
	color.rgb = halfLambert*color.rgb;
	return float4(color.rgb,halfLambert);
}

technique11 RenderScene
{
	pass P0
	{
		SetVertexShader(CompileShader(vs_5_0,VS()));
		SetPixelShader(CompileShader(ps_5_0,PS()));
	}
}


//----------------------------------------------------------------------------------
// Fullscreen passes

struct PostProc_VSOut
{
    float2 uv   : TEXCOORD0;
    float4 pos  : SV_Position;
};

PostProc_VSOut FullScreenTriangle_VS( uint id : SV_VertexID )
{
    PostProc_VSOut output = (PostProc_VSOut)0.0f;
    output.uv = float2( (id << 1) & 2, id & 2 );
    output.pos = float4( output.uv * float2( 2.0f, -2.0f ) + float2( -1.0f, 1.0f) , 0.5f, 1.0f );
    return output;
}

DepthStencilState FullscreenQuadDS
{
	DepthEnable=false;
	StencilEnable=false;
	DepthWriteMask=zero;
};

Texture2D CopyTexture;

float4 FullscreenCopy_PS(float2 vInUV : TEXCOORD0) : SV_Target
{
    return float4(CopyTexture.Sample( LinearClampSampler, vInUV ).xyz,1);
}

technique11 RenderFullscreenCopy
{
	pass P0
	{
		SetDepthStencilState(FullscreenQuadDS,0);
		SetVertexShader(CompileShader(vs_5_0,FullScreenTriangle_VS()));
		SetPixelShader(CompileShader(ps_5_0,FullscreenCopy_PS()));
	}
}

//----------------------------------------------------------------------------------
// TXAA custom Depth resolve

BlendState ZOnlyBlend
{
	RenderTargetWriteMask[0]=0;
};

DepthStencilState ResolveDepthDS
{
	DepthEnable=true;	
	StencilEnable=false;
	DepthWriteMask=all;	
	DepthFunc=always;	// always pass to write every texel
};

RasterizerState CullNoneRS
{
	DepthClipEnable=false;
	CullMode=None;
};

Texture2DMS<float4> SceneDepthTextureMS;

float ResolveDepth(float2 InUVs) 
{
	float2 dimensions; 	int samples;

	SceneDepthTextureMS.GetDimensions(dimensions.x,dimensions.y,samples);

	int3 loadAddress = int3(InUVs*dimensions,0);

	float minDepth = 1000000;	
	for(int index = 0;index < samples;++index)
	{
		float s = SceneDepthTextureMS.Load(loadAddress,index).r;
		minDepth = min(minDepth,s);
	}
	return minDepth;
}

// Writes to SV_Depth
void ResolveDepthPixelShader(in float2 InUVs : TEXCOORD0, out float depth : SV_Depth) 
{
	depth = ResolveDepth(InUVs);
}

// Writes to SV_Target
void ResolveDepthIntoColorPixelShader(in float2 InUVs : TEXCOORD0, out float color : SV_Target) 
{
	color = ResolveDepth(InUVs);
}

technique11 ResolveDepthToDSV
{
	pass P0
	{
		SetRasterizerState(CullNoneRS);
		SetBlendState(ZOnlyBlend,float4(0,0,0,0),0);
		SetDepthStencilState(ResolveDepthDS,0);
		SetVertexShader(CompileShader(vs_5_0,FullScreenTriangle_VS()));
		SetPixelShader(CompileShader(ps_5_0,ResolveDepthPixelShader()));
	}
}

technique11 ResolveDepthToRTV
{
	pass P0
	{
		SetRasterizerState(CullNoneRS);
		SetDepthStencilState(FullscreenQuadDS,0);
		SetVertexShader(CompileShader(vs_5_0,FullScreenTriangle_VS()));
		SetPixelShader(CompileShader(ps_5_0,ResolveDepthIntoColorPixelShader()));
	}
}

//----------------------------------------------------------------------------------
// TXAA motion vector gen

Texture2D SceneDepthTexture;	// Resolved hardware depth

cbuffer CameraMotionConstants
{
	float4 const0;  // constants generated by CameraMotionConstants() function
	float4 const1;
	float4 const2;
	float4 const3;
	float4 const4;
}

// simplified global motion generation code from Timothy
float2 CameraMotionVector(
	float3 xyd // {x,y} = position on screen range 0 to 1, d = fetched depth
	)
{ 
	float2 mv;
	float scaleM = 1.0/(dot(xyd, const0.xyz) + const0.w);
	mv.x = ((xyd.x * ((const1.x * xyd.y) + (const1.y * xyd.z) + const1.z)) + (const1.w * xyd.y) + (const2.x * xyd.x * xyd.x) + (const2.y * xyd.z) + const2.z) * scaleM;
	mv.y = ((xyd.y * ((const3.x * xyd.x) + (const3.y * xyd.z) + const3.z)) + (const3.w * xyd.x) + (const4.x * xyd.y * xyd.y) + (const4.y * xyd.z) + const4.z) * scaleM;
	return mv; 
}

cbuffer CameraMotionConstants2
{
	float4x4 Current2PrevTransform;	// transforms the current pixel into the previous frames camera clip space
	float2 ScreenSize;
}

float4 CameraMotionMainPixelShader(in float2 InUVs : TEXCOORD0) : SV_Target
{
	float2 ScreenUV = InUVs;
	float DeviceZ = SceneDepthTexture.Sample( PointClampSampler, ScreenUV ).x;

	float2 ScreenMotion = (float2)0;

#if 1	// $$ USE SIMPLIFIED CAMERA MOTION?
	// Use simplified camera motion calculation
	ScreenMotion = CameraMotionVector(float3(ScreenUV.xy,DeviceZ));
#else

	float2 ClipPos = float2(InUVs.x, 1 - InUVs.y) * 2 - 1;
	float4 LastClipPos = mul(float4(ClipPos.xy,DeviceZ,1),Current2PrevTransform);
	LastClipPos.xy /= LastClipPos.w; 

	float2 ClipDiff = LastClipPos.xy-ClipPos.xy;

	ScreenMotion = ClipDiff * float2(0.5,-0.5);		

#endif

	return float4(ScreenMotion.xy,0,0);
}

technique11 RenderMotionVectorsCameraSpace
{
	pass P0
	{
		SetDepthStencilState(FullscreenQuadDS,0);
		SetVertexShader(CompileShader(vs_5_0,FullScreenTriangle_VS()));
		SetPixelShader(CompileShader(ps_5_0,CameraMotionMainPixelShader()));
	}
}


