/*===========================================================================


                         CAMERA MOTION HELPER CODE


-----------------------------------------------------------------------------
TXAA is not public domain, however this file is public domain.
This shows as reference what is needed by some TXAA inputs.
This file is simple C form of equations which are generated by Mathematica.
These equations are also useful for things like SSAO with temporal filtering.
As many internet sources have presented incorrect solutions
this serves to show a correct solution which has been fully tested.
-----------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LICENSE

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or distribute 
this software, either in source code form or as a compiled binary, for any 
purpose, commercial or non-commercial, and by any means.

In jurisdictions that recognize copyright laws, the author or authors of 
this software dedicate any and all copyright interest in the software to 
the public domain. We make this dedication for the benefit of the public 
at large and to the detriment of our heirs and successors. We intend this 
dedication to be an overt act of relinquishment in perpetuity of all 
present and future rights to this software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
===========================================================================*/


#include "GFSDK_TXAA_Common.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*===========================================================================
                       INVERSION WITH FORMAT CONVERSION
===========================================================================*/
// Float matrix input and double output for CameraMotionConstants().
static inline void Inverse4x4(
gfsdk_F8* __GFSDK_RESTRICT__ const d, // destination
const gfsdk_F4* __GFSDK_RESTRICT__ const s // source
) {
  gfsdk_F8 inv[16]; gfsdk_F8 det; gfsdk_U4 i;
/*-------------------------------------------------------------------------*/
  const gfsdk_F8 s0  = (gfsdk_F8)(s[ 0]); const gfsdk_F8 s1  = (gfsdk_F8)(s[ 1]); const gfsdk_F8 s2  = (gfsdk_F8)(s[ 2]); const gfsdk_F8 s3  = (gfsdk_F8)(s[ 3]);
  const gfsdk_F8 s4  = (gfsdk_F8)(s[ 4]); const gfsdk_F8 s5  = (gfsdk_F8)(s[ 5]); const gfsdk_F8 s6  = (gfsdk_F8)(s[ 6]); const gfsdk_F8 s7  = (gfsdk_F8)(s[ 7]);
  const gfsdk_F8 s8  = (gfsdk_F8)(s[ 8]); const gfsdk_F8 s9  = (gfsdk_F8)(s[ 9]); const gfsdk_F8 s10 = (gfsdk_F8)(s[10]); const gfsdk_F8 s11 = (gfsdk_F8)(s[11]);
  const gfsdk_F8 s12 = (gfsdk_F8)(s[12]); const gfsdk_F8 s13 = (gfsdk_F8)(s[13]); const gfsdk_F8 s14 = (gfsdk_F8)(s[14]); const gfsdk_F8 s15 = (gfsdk_F8)(s[15]);
/*-------------------------------------------------------------------------*/
  inv[0]  =  s5 * s10 * s15 - s5 * s11 * s14 - s9 * s6 * s15 + s9 * s7 * s14 + s13 * s6 * s11 - s13 * s7 * s10;
  inv[1]  = -s1 * s10 * s15 + s1 * s11 * s14 + s9 * s2 * s15 - s9 * s3 * s14 - s13 * s2 * s11 + s13 * s3 * s10;
  inv[2]  =  s1 * s6  * s15 - s1 * s7  * s14 - s5 * s2 * s15 + s5 * s3 * s14 + s13 * s2 * s7  - s13 * s3 * s6;
  inv[3]  = -s1 * s6  * s11 + s1 * s7  * s10 + s5 * s2 * s11 - s5 * s3 * s10 - s9  * s2 * s7  + s9  * s3 * s6;
  inv[4]  = -s4 * s10 * s15 + s4 * s11 * s14 + s8 * s6 * s15 - s8 * s7 * s14 - s12 * s6 * s11 + s12 * s7 * s10;
  inv[5]  =  s0 * s10 * s15 - s0 * s11 * s14 - s8 * s2 * s15 + s8 * s3 * s14 + s12 * s2 * s11 - s12 * s3 * s10;
  inv[6]  = -s0 * s6  * s15 + s0 * s7  * s14 + s4 * s2 * s15 - s4 * s3 * s14 - s12 * s2 * s7  + s12 * s3 * s6;
  inv[7]  =  s0 * s6  * s11 - s0 * s7  * s10 - s4 * s2 * s11 + s4 * s3 * s10 + s8  * s2 * s7  - s8  * s3 * s6;
  inv[8]  =  s4 * s9  * s15 - s4 * s11 * s13 - s8 * s5 * s15 + s8 * s7 * s13 + s12 * s5 * s11 - s12 * s7 * s9;
  inv[9]  = -s0 * s9  * s15 + s0 * s11 * s13 + s8 * s1 * s15 - s8 * s3 * s13 - s12 * s1 * s11 + s12 * s3 * s9;
  inv[10] =  s0 * s5  * s15 - s0 * s7  * s13 - s4 * s1 * s15 + s4 * s3 * s13 + s12 * s1 * s7  - s12 * s3 * s5;
  inv[11] = -s0 * s5  * s11 + s0 * s7  * s9  + s4 * s1 * s11 - s4 * s3 * s9  - s8  * s1 * s7  + s8  * s3 * s5;
  inv[12] = -s4 * s9  * s14 + s4 * s10 * s13 + s8 * s5 * s14 - s8 * s6 * s13 - s12 * s5 * s10 + s12 * s6 * s9;
  inv[13] =  s0 * s9  * s14 - s0 * s10 * s13 - s8 * s1 * s14 + s8 * s2 * s13 + s12 * s1 * s10 - s12 * s2 * s9;
  inv[14] = -s0 * s5  * s14 + s0 * s6  * s13 + s4 * s1 * s14 - s4 * s2 * s13 - s12 * s1 * s6  + s12 * s2 * s5;
  inv[15] =  s0 * s5  * s10 - s0 * s6  * s9  - s4 * s1 * s10 + s4 * s2 * s9  + s8  * s1 * s6  - s8  * s2 * s5;
/*-------------------------------------------------------------------------*/
  det = (s0 * inv[0] + s1 * inv[4] + s2 * inv[8] + s3 * inv[12]);
  if(det != 0.0) det = 1.0/det;
  for(i=0; i<16; i++) d[i] = inv[i] * det; }

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*===========================================================================
                       CAMERA MOTION CONSTANT GENERATION
-----------------------------------------------------------------------------
HLSL CODE FOR SHADER
--------------------
float2 CameraMotionVector(
float3 xyd, // {x,y} = position on screen range 0 to 1, d = fetched depth
float4 const0,  // constants generated by CameraMotionConstants() function
float4 const1,
float4 const2,
float4 const3,
float4 const4)
{ 
  float2 mv;
  gfsdk_F4 scaleM = 1.0/(dot(xyd, const0.xyz) + const0.w);
  mv.x = ((xyd.x * ((const1.x * xyd.y) + (const1.y * xyd.z) + const1.z)) + (const1.w * xyd.y) + (const2.x * xyd.x * xyd.x) + (const2.y * xyd.z) + const2.z) * scaleM;
  mv.y = ((xyd.y * ((const3.x * xyd.x) + (const3.y * xyd.z) + const3.z)) + (const3.w * xyd.x) + (const4.x * xyd.y * xyd.y) + (const4.y * xyd.z) + const4.z) * scaleM;
  return mv; }
===========================================================================*/
static inline void CameraMotionConstants(
gfsdk_F4* __GFSDK_RESTRICT__ const cb, // constant buffer output
const gfsdk_F8* __GFSDK_RESTRICT__ const c, // current view projection matrix inverse
const gfsdk_F4* __GFSDK_RESTRICT__ const p  // prior view projection matrix
) {
/*-------------------------------------------------------------------------*/
  const gfsdk_F8 cxx = c[ 0]; const gfsdk_F8 cxy = c[ 1]; const gfsdk_F8 cxz = c[ 2]; const gfsdk_F8 cxw = c[ 3];
  const gfsdk_F8 cyx = c[ 4]; const gfsdk_F8 cyy = c[ 5]; const gfsdk_F8 cyz = c[ 6]; const gfsdk_F8 cyw = c[ 7];
  const gfsdk_F8 czx = c[ 8]; const gfsdk_F8 czy = c[ 9]; const gfsdk_F8 czz = c[10]; const gfsdk_F8 czw = c[11];
  const gfsdk_F8 cwx = c[12]; const gfsdk_F8 cwy = c[13]; const gfsdk_F8 cwz = c[14]; const gfsdk_F8 cww = c[15];
/*-------------------------------------------------------------------------*/
  const gfsdk_F8 pxx = (gfsdk_F8)(p[ 0]); const gfsdk_F8 pxy = (gfsdk_F8)(p[ 1]); const gfsdk_F8 pxz = (gfsdk_F8)(p[ 2]); const gfsdk_F8 pxw = (gfsdk_F8)(p[ 3]);
  const gfsdk_F8 pyx = (gfsdk_F8)(p[ 4]); const gfsdk_F8 pyy = (gfsdk_F8)(p[ 5]); const gfsdk_F8 pyz = (gfsdk_F8)(p[ 6]); const gfsdk_F8 pyw = (gfsdk_F8)(p[ 7]);
  const gfsdk_F8 pwx = (gfsdk_F8)(p[12]); const gfsdk_F8 pwy = (gfsdk_F8)(p[13]); const gfsdk_F8 pwz = (gfsdk_F8)(p[14]); const gfsdk_F8 pww = (gfsdk_F8)(p[15]);
/*-------------------------------------------------------------------------*/
  // c0
  cb[0] = (gfsdk_F4)(4.0*(cwx*pww + cxx*pwx + cyx*pwy + czx*pwz));
  cb[1] = (gfsdk_F4)((-4.0)*(cwy*pww + cxy*pwx + cyy*pwy + czy*pwz));
  cb[2] = (gfsdk_F4)(2.0*(cwz*pww + cxz*pwx + cyz*pwy + czz*pwz));
  cb[3] = (gfsdk_F4)(2.0*(cww*pww - cwx*pww + cwy*pww + (cxw - cxx + cxy)*pwx + (cyw - cyx + cyy)*pwy + (czw - czx + czy)*pwz));
/*-------------------------------------------------------------------------*/
  // c1
  cb[4] = (gfsdk_F4)(( 4.0)*(cwy*pww + cxy*pwx + cyy*pwy + czy*pwz));
  cb[5] = (gfsdk_F4)((-2.0)*(cwz*pww + cxz*pwx + cyz*pwy + czz*pwz));
  cb[6] = (gfsdk_F4)((-2.0)*(cww*pww + cwy*pww + cxw*pwx - 2.0*cxx*pwx + cxy*pwx + cyw*pwy - 2.0*cyx*pwy + cyy*pwy + czw*pwz - 2.0*czx*pwz + czy*pwz - cwx*(2.0*pww + pxw) - cxx*pxx - cyx*pxy - czx*pxz));  
  cb[7] = (gfsdk_F4)(-2.0*(cyy*pwy + czy*pwz + cwy*(pww + pxw) + cxy*(pwx + pxx) + cyy*pxy + czy*pxz));  
/*-------------------------------------------------------------------------*/
  // c2
  cb[ 8] = (gfsdk_F4)((-4.0)*(cwx*pww + cxx*pwx + cyx*pwy + czx*pwz));  
  cb[ 9] = (gfsdk_F4)(cyz*pwy + czz*pwz + cwz*(pww + pxw) + cxz*(pwx + pxx) + cyz*pxy + czz*pxz);  
  cb[10] = (gfsdk_F4)(cwy*pww + cwy*pxw + cww*(pww + pxw) - cwx*(pww + pxw) + (cxw - cxx + cxy)*(pwx + pxx) + (cyw - cyx + cyy)*(pwy + pxy) + (czw - czx + czy)*(pwz + pxz));  
  cb[11] = (gfsdk_F4)(0);  
/*-------------------------------------------------------------------------*/
  // c3
  cb[12] = (gfsdk_F4)((-4.0)*(cwx*pww + cxx*pwx + cyx*pwy + czx*pwz));  
  cb[13] = (gfsdk_F4)((-2.0)*(cwz*pww + cxz*pwx + cyz*pwy + czz*pwz));  
  cb[14] = (gfsdk_F4)(2.0*((-cww)*pww + cwx*pww - 2.0*cwy*pww - cxw*pwx + cxx*pwx - 2.0*cxy*pwx - cyw*pwy + cyx*pwy - 2.0*cyy*pwy - czw*pwz + czx*pwz - 2.0*czy*pwz + cwy*pyw + cxy*pyx + cyy*pyy + czy*pyz));  
  cb[15] = (gfsdk_F4)(2.0*(cyx*pwy + czx*pwz + cwx*(pww - pyw) + cxx*(pwx - pyx) - cyx*pyy - czx*pyz));  
/*-------------------------------------------------------------------------*/
  // c4
  cb[16] = (gfsdk_F4)(4.0*(cwy*pww + cxy*pwx + cyy*pwy + czy*pwz));  
  cb[17] = (gfsdk_F4)(cyz*pwy + czz*pwz + cwz*(pww - pyw) + cxz*(pwx - pyx) - cyz*pyy - czz*pyz);
  cb[18] = (gfsdk_F4)(cwy*pww + cww*(pww - pyw) - cwy*pyw + cwx*((-pww) + pyw) + (cxw - cxx + cxy)*(pwx - pyx) + (cyw - cyx + cyy)*(pwy - pyy) + (czw - czx + czy)*(pwz - pyz));  
  cb[19] = (gfsdk_F4)(0); }
